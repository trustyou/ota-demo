
<html>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <meta name="robots" content="noindex, nofollow"/>
  <title>Search Results</title>
  <link rel="stylesheet" type="text/css" href="css/style.css"/>
  <link rel="stylesheet" type="text/css" href="css/results.css"/>
  <link rel="stylesheet" href="//fonts.googleapis.com/css2?family=Playfair+Display&amp;family=Roboto&amp;display=swap"/>
  <link rel="stylesheet" href="//cdn.integration.trustyou.com/apps/trustyou-iconic/public/css/trustyou-iconic.min.latest.css"/>
  <body>
    <div id="search-page"></div>
    <script type="text/javascript" src="js/polifill.js"></script>
    <script type="text/javascript" src="js/common.js"></script>
    <script type="text/babel">
      const { Select } = antd;

let timeout;
let currentValue;

function fetchCities(value, callback) {
  if (timeout) {
    clearTimeout(timeout);
    timeout = null;
  }
  currentValue = value;

  function citySearch() {
    axios({
        method: 'get',
        url: `${OTA_DEMO_API_URL}/api/v1/city_search/?q=${value}`
      })
      .then(response => response.data.cities)
      .then(result => {
        if (currentValue === value) {
          callback(result);
        }
      });
  }

  timeout = setTimeout(citySearch, 200);
}

class SearchLocation extends React.Component {
  state = {
    data: [],
    value: undefined,
  };

  handleSearch = value => {
    if (value) {
      fetchCities(value, data => this.setState({ data }));
    } else {
      this.setState({ data: [] });
    }
  };

  handleChange = value => {
    this.setState({ value });
    this.props.handleChange(value)
  };

  componentDidUpdate(prevProps) {
    if (prevProps.value !== this.props.value) {
      this.setDefault(this.props.value);
    }
  }

  componentDidMount() {
    if (this.props.value) {
      this.setDefault(this.props.value);
    }
  }

  setDefault = (value) => {
    const locationData =parseCityCountry(value)
    if (locationData) {
      const initData = {
        city: toTitleCase(locationData[0]),
        country: toTitleCase(locationData[1])
      }

      this.setState({
        value: `${initData.city} - ${initData.country}`,
        data: [
          initData
        ],
      })
    }
  }

  render() {
    const options = this.state.data.map(d => <Option key={`${d.city}--${d.country}`}>{d.city} - {d.country}</Option>);

    return (
      <Select
        showSearch
        value={this.state.value}
        placeholder={this.props.placeholder}
        style={this.props.style}
        defaultActiveFirstOption={false}
        showArrow={false}
        filterOption={false}
        onSearch={this.handleSearch}
        onChange={this.handleChange}
        notFoundContent={null}
      >
        {options}
      </Select>
    );
  }
}
      class MapContainer extends React.Component {
    componentDidUpdate(prevProps) {
        if (prevProps.lat !== this.props.lat || prevProps.lon !== this.props.lon
            || (prevProps.isStaleMap !== this.props.isStaleMap && this.props.isStaleMap)) {
            RESULT_MAP = buildMap(this.props.lat, this.props.lon);
            RESULT_MAP.on('zoomend', () => this.mapChanged());
            RESULT_MAP.on('dragend', () => this.mapChanged());
        }

        if (prevProps.newHotels !== this.props.newHotels) {
            this.props.newHotels.forEach(h => {
                const { ty_id, coordinates } = h;
                if (coordinates) {
                    addMarker(ty_id, h.match.match_score, coordinates[0], coordinates[1], this.getMarkerPopup(h));
                }
            });
        }

        // Change map center
        if (prevProps.centerLat !== this.props.centerLat || prevProps.centerLon !== this.props.centerLon) {
            // Open marker
            RESULT_MAP_MARKERS[this.props.selectedHotelId] && RESULT_MAP_MARKERS[this.props.selectedHotelId].openPopup();
            // Center map to hotel
            RESULT_MAP.panTo(new L.LatLng(this.props.centerLat, this.props.centerLon));
        }
    }

    mapChanged = () => {
        // TODO Trigger search
        var coordinates = {
            lat: RESULT_MAP.getCenter().lat,
            lon: RESULT_MAP.getCenter().lng,
            radis: 100,
            zoom: RESULT_MAP.getZoom(),
        }
    }

    getMarkerPopup(hotel) {
        const { name, score, score_description} = hotel;
        return `<b>${name}</b>
            <div class="trustscore score-marker">
            <div class="score">${score}</div>
            <div class="details">
              <div class="label">${score_description}</div>
            </div>
          </div>
        `;
    }

    render() {
        return (
            <div className={this.props.isMapFloating ? 'map-container-float' : 'map-container'}>
                <section className="search-map" id="search-map"></section>
                <div className="score-gradient">
                    <div className="preference-match">Preference match</div>
                    <img src="img/score-gradient.png" />
                    <div className="match-legend">
                        <span className="match-low">Low</span>
                        <span className="match-high">High</span>
                    </div>
                </div>
            </div>
        )
    }
}
      
function NoResult({}) {
  return <div className="placeholder-box">
    <div className="placeholder-box-icon">
      <i className="ty-icon ty-icon-database-search"></i>
    </div>
    <div className="placeholder-box-title">No hotels found</div>
    <div className="placeholder-box-subtitle">This might be due to the selected location or because of invalid search parameters.</div>
  </div>
}

function ErrorMessage({}) {
  return <div className="placeholder-box">
    <div className="placeholder-box-icon">
      <i className="ty-icon ty-icon-database-search"></i>
    </div>
    <div className="placeholder-box-title">There is an error occurred</div>
    <div className="placeholder-box-subtitle">Please try again.</div>
  </div>
}

function RelevantNow({relevantNow}) {
  var scoreTrendItems = []
  var categoriesItems = []
  var relevantNowScoreTrendText = ''
  var relevantNowCategoriesText = ''

  if (relevantNow.overall_satisfaction && relevantNow.overall_satisfaction.score) {
    const recentRating = relevantNow.overall_satisfaction.score
    const reviewsCount = relevantNow.overall_satisfaction.reviews_count
    scoreTrendItems.push(
      `<span class="recent-rating">Recent rating: <span class="pill has-tooltip">
        <b>${recentRating}</b>
        <div class="tooltip">
          <div>Based on ${reviewsCount} ${reviewsCount === 1 ? "review" : "reviews"}</div>
        </div>
      </span>`
    );
    if (relevantNow.overall_satisfaction.trend) {
      const recentTrend = relevantNow.overall_satisfaction.trend
      const recentTrendText = (recentTrend > 0) ? '+' + recentTrend : recentTrend
      const trendClassName = (recentTrend > 0) ? 'text-positive': 'text-negative'
      scoreTrendItems.push(`<span class="rating-trend ${trendClassName}">${recentTrendText}</span>`)
    }

    relevantNowScoreTrendText = scoreTrendItems.join('')
  }

  if (relevantNow.relevant_topics) {
    for (var key in relevantNow.relevant_topics) {
      const val = relevantNow.relevant_topics[key]
      const reviewsCount = val.reviews_count
      categoriesItems.push(
        `<span class="relevant-topic">${val.name}: <span class="pill has-tooltip">
          <b>${val.score}</b>
          <div class="tooltip">
            <div>Based on ${reviewsCount} ${reviewsCount === 1 ? "review" : "reviews"}</div>
          </div>
        </span></span>`
      )
    }

    relevantNowCategoriesText = categoriesItems.join('')
  }

  return <div className="relevant-now">
    {relevantNowScoreTrendText && <span dangerouslySetInnerHTML={{ __html: relevantNowScoreTrendText }}></span>}
    {relevantNowCategoriesText && <span dangerouslySetInnerHTML={{ __html: relevantNowCategoriesText }}></span>}
  </div>
}

function SearchSummaryItem({kind, text, value, onClick}) {
  return <span key={`${kind}-${value}`} className="search-tag">{text}
    <i className="ty-icon ty-icon-remove" data-kind={kind} data-value={value} onClick={onClick}></i>
  </span>
}

function SearchSummary({onItemRemoved, selectedCategories, selectedTripTypes, selectedOccasions}) {
  var onClick = (e) => {
    onItemRemoved(
      e.target.attributes["data-kind"].value,
      e.target.attributes["data-value"].value
    );
  }

  if (selectedCategories.length === 0 && selectedTripTypes.length === 0 &&  selectedOccasions.length === 0) {
    return <></>
  }

  return <div className="search-summary">
    Your custom preferences:

    <>
    {selectedCategories.map(
      category => <SearchSummaryItem
        key={category}
        kind="category"
        text={JSON.parse(category).name}
        value={JSON.parse(category).category_id}
        onClick={onClick}
      />
    )}
    </>

    <>
    {selectedTripTypes.map(
      ({id, name}) => <SearchSummaryItem
        key={id}
        kind="tripType"
        text={name}
        value={id}
        onClick={onClick}
      />
    )}
    </>
    <>
    {selectedOccasions.map(
      ({id, name}) => <SearchSummaryItem
        key={id}
        kind="occasion"
        text={name}
        value={id}
        onClick={onClick}
      />
    )}
    </>
  </div>
}

class SearchHeader extends React.Component {
  state = {
    categories: [],
    location: '',
    city: '',
    country: '',
    tripTypes: [],
    occasions: [],
    isOpen: false,
  }

  applyFilter = () => {
    if (!this.props.isSearching) {
      this.props.onApplyChanges(this.state);
    }
  }

  applyCategoryChange = (categories) => {
    this.setState({
      categories
    })
  }

  applyTripsChange = (trips) => {
    this.setState({
      tripTypes: trips
    })
  }

  applyOccasionsChange = (occasions) => {
    this.setState({
      occasions
    })
  }

  applyLocationChange = (location) => {
    if (location !== this.state.location) {
      const locationFilter = parseCityCountry(location)
      this.setState({
        location,
        city: locationFilter[0],
        country: locationFilter[1],
      });
      this.props.onApplyLocationChange(location);
    }
  }

  onSearchSummaryItemRemoved = (kind, value) => {
    var newState = null;

    if (kind === "category") {
      const newCategories = this.state.categories.filter(x => JSON.parse(x).category_id !== value)
      newState = {
        categories: newCategories,
      };
    } else if (kind == "tripType") {
      const newTripTypes = this.state.tripTypes.filter(x => x.id !== value)
      newState = {
        tripTypes: newTripTypes,
      };
    } else if (kind == "occasion") {
      const newOccasions = this.state.occasions.filter(x => x.id !== value)
      newState = {
        occasions: newOccasions,
      };
    }
    // TODO Check isOpen == false?
    if (newState && !this.props.isSearching) {
      this.setState(newState, () => this.props.onApplyChanges(this.state));
    }
  }

  clearFilter = () => {
    this.setState({
      categories: [],
      tripTypes: [],
      occasions: [],
    });
  }

  componentDidUpdate(prevProps) {
    const newState = {};

    if (prevProps.isOpen !== this.props.isOpen) {
      newState["isOpen"] = this.props.isOpen;
    }

    if (prevProps.categories !== this.props.categories) {
      newState["categories"] = this.props.categories;
    }

    if (prevProps.occasions !== this.props.occasions) {
      newState["occasions"] = this.props.occasions;
    }

    if (prevProps.tripTypes !== this.props.tripTypes) {
      newState["tripTypes"] = this.props.tripTypes;
    }

    if (Object.keys(newState).length > 0) {
      this.setState(newState);
    }
  }

  componentDidMount() {
    const selectedLocation = getLocationSearchInUrl("location")
    const locationFilter = parseCityCountry(selectedLocation);

    const initState = {
      isOpen: this.props.isOpen,
    }

    if (locationFilter) {
      initState['location'] = selectedLocation;
      initState['city'] = locationFilter[0];
      initState['country'] = locationFilter[1];
    }
    this.setState(initState)
  }

  render() {
    return <header>
      <form className="search-form" id="search-form" action="results.html">
        <div className="search-container">
          <fieldset className="search-primary" id="search-primary">
            { (this.props.totalCount == null) && <legend> Searching... </legend> }
            { this.props.totalCount && <legend> You have {this.props.totalCount.toLocaleString()} results for <em
              id="search-location-legend">{toTitleCase(this.state.city)} - {toTitleCase(this.state.country)}</em>
              </legend>
            }
            <div className="search-box">
              <SearchLocation value={this.state.location} handleChange={this.applyLocationChange} placeholder="Try another destination?"/>
              <i className="ty-icon ty-icon-search"></i>
            </div>
            <SearchSummary
              selectedCategories={this.state.categories}
              selectedTripTypes={this.state.tripTypes}
              selectedOccasions={this.state.occasions}
              onItemRemoved={this.onSearchSummaryItemRemoved}
            />
          </fieldset>
          <fieldset className="search-secondary">
            <div className={`search-preferences ${this.state.isOpen ? 'is-open' : ''}`} id="search-preferences">
              <CategoryFilter onChange={this.applyCategoryChange} selected={this.state.categories} mrCategories={this.props.mrCategories}/>
              <TripsFilter onChange={this.applyTripsChange} selected={this.state.tripTypes}/>
              <OccasionsFilter onChange={this.applyOccasionsChange} selected={this.state.occasions}/>
              <input
                className="form-submit btn btn-positive btn-lg"
                type="button"
                value={this.props.isSearching ? 'Searching...' : 'Apply changes'}
                onClick={this.applyFilter}
              />
              <input className="form-reset" type="reset" value="Clear selection" onClick={this.clearFilter}/>
            </div>
            <div className="search-toggle" id="search-toggle" onClick={this.props.toggleSearch}>
              <span>{!this.state.isOpen ? 'Select your preferences' : 'Hide preferences' }</span>
              <i className={`ty-icon ty-icon-chevron-${this.state.isOpen ? 'up' : 'down'}`}></i>
            </div>
          </fieldset>
        </div>
      </form>
    </header>
  }
}

class TripsFilter extends React.Component {
  state = {
    selected: [],
  }

  allTrips = () => {
    // TODO API call?
    return ALL_TRIP_TYPES;
  }

  handleClick = (e) => {
    const { value } = e.target
    var selectedItems = this.state.selected

    const index = selectedItems.indexOf(value);

    if (index > -1) {
      selectedItems.splice(index, 1);
    } else {
      selectedItems = [value]
    }

    this.setState({
      selected: selectedItems,
    }, () => {
      this.props.onChange(this.allTrips().filter(t => selectedItems.includes(t.id)))
    });
  }

  componentDidUpdate(prevProps) {
    if (prevProps.selected !== this.props.selected) {
      this.setState({
        selected: this.props.selected.map(a => a.id),
      });
    }
  }

  componentDidMount() {
    this.setState({
      selected: this.props.selected.map(a => a.id),
    })
  }

  render() {
    const { selected } = this.state;

    return <fieldset>
      <legend>What kind of trip did you have in mind?</legend>
      {
        this.allTrips().map(({id, name, icon}) => <label key={id} className={selected.includes(id) ? "is-selected" : ""}>
          <input
            type="checkbox"
            defaultChecked={selected.includes(id)}
            onClick={this.handleClick}
            name={name}
            value={id}
          />
            <i className={`ty-icon ty-icon-${icon}`}></i>
            {capitalize(name)}
        </label>)
      }
    </fieldset>
  }
}

class OccasionsFilter extends React.Component {
  state = {
    selected: [],
  }

  allOccasions = () => {
    return ALL_OCCASIONS;
  }

  handleClick = (e) => {
    const { value } = e.target
    var selectedItems = this.state.selected

    const index = selectedItems.indexOf(value);

    if (index > -1) {
      selectedItems.splice(index, 1);
    } else {
      selectedItems = [value]
    }

    this.setState({
      selected: selectedItems,
    }, () => {
      this.props.onChange(this.allOccasions().filter(t => selectedItems.includes(t.id)))
    })
  }

  componentDidUpdate(prevProps) {
    if (prevProps.selected !== this.props.selected) {
      this.setState({
        selected: this.props.selected.map(i => i.id),
      })
    }
  }

  componentDidMount() {
    this.setState({
      selected: this.props.selected.map(i => i.id),
    })
  }

  render() {
    const { selected } = this.state;

    return <fieldset>
      <legend>Any special occasion for this trip?</legend>
      {
        this.allOccasions().map(
          ({id, name, icon}) =>
          <label key={id} className={selected.includes(id) ? "is-selected" : ""}>
            <input
              type="checkbox"
              defaultChecked={selected.includes(id)}
              onClick={this.handleClick}
              name={name}
              value={id}
            />
              <i className={`ty-icon ty-icon-${icon}`}></i>
              {name}
          </label>
        )
      }
    </fieldset>
  }
}

class CategoryFilter extends React.Component {
  state = {
    selected: null,
  }

  updateValue = (selected) => {
    this.setState({ selected });
    this.props.onChange(selected)
  }

  componentDidUpdate(prevProps) {
    if (prevProps.selected !== this.props.selected) {
      this.setState({
        selected: this.props.selected,
      })
    }
  }

  componentDidMount() {
    this.setState({
      selected: this.props.selected,
    })
  }

  render() {
    const sortedMrCategories = this.props.mrCategories.sort(
      (a,b) => {
        const a_tokens = a.name.split(" ").length
        const b_tokens = b.name.split(" ").length
        return (a_tokens > b_tokens) ? 1 : (
            (b_tokens > a_tokens) ? -1 : (
                (a.name > b.name) ? 1 : (b.name > a.name ? -1 : 0)
            )
        )
      }
    )
    const options = sortedMrCategories.map(
      cat => <antd.Select.Option
          key={JSON.stringify({category_id: cat.category_id, name: cat.name})}>{cat.name}
        </antd.Select.Option>
    );
    const { selected } = this.state;

    return <fieldset>
      <legend>What is most relevant for your trip?</legend>
      <div className="search-categories">
        <antd.Select
          showArrow={false}
          mode="multiple"
          allowClear
          placeholder="e.g. cleanliness, breakfast, wifi"
          showSearch
          onChange={this.updateValue}
          value={selected}
          filterOption={(input, option) =>
            option.children.toLowerCase().indexOf(input.toLowerCase()) >= 0
          }
        >
          {options}
        </antd.Select>
      </div>
    </fieldset>
  }
}

function Loader({itemCount}) {
  return <div id="spinner">
    {[...Array(itemCount).keys()].map(item => <article key={`spinner-${item}`} className="hotel">
        <div className="hotel-image"></div>
        <div className="hotel-details">
          <div className="placeholder-text"></div>
          <div className="placeholder-text"></div>
        </div>
        <div className="hotel-actions">
          <div className="placeholder-btn"></div>
          <div className="placeholder-text"></div>
        </div>
      </article>
    )}
  </div>;
}

function HotelCategories({hotelId, categories, highlightCategories}) {
  return <ul className="categories">
    {
      categories.slice(0, 3).map(category => <li key={`${hotelId}-${category.category_id}`}>
        <div className="has-tooltip">
          <span className={ highlightCategories ? "matched-category category pill" : "category pill"}>
            {category.category_name}: {category.score}
          </span>
          { category.review_count > 0 && <div className="tooltip">
              <div>Based on {category.review_count} {category.review_count === 1 ? "review" : "reviews"}</div>
            </div>
          }
        </div>
      </li>)
    }
  </ul>;
}

function HotelBadges({hotelId, badges}) {
  const badge = badges.length > 0 ? badges[0]: null

  return <>
    { badge && <>
      <div className="badges">
        <ul className="badges-list">
          <li
            key={`${hotelId}-${badge.badge_type}-${badge.badge_data.category_name}-${badge.subtext}`}
            className="has-tooltip"
          >
            <div className="tooltip">
              { !badge.subtext && <span dangerouslySetInnerHTML={{ __html: badge.text }}></span>}
              {badge.subtext}
            </div>
            <div className="badge">
                <div className="icon-wrapper"><i className={`ty-icon ty-icon-${badge.icon || "trophy"}`}></i></div>
                <div className="ribbon-tail"></div>
            </div>
            <div className="rank-value">
              <span dangerouslySetInnerHTML={{ __html: badge.text }}></span>
            </div>
          </li>
        </ul>
      </div>
    </>
    }
  </>;
}

class Hotel extends React.Component {
  render() {
    const { hotel, randomIndex, isPersonalizedSearch, filterOccasions, filterCategories } = this.props
    const randomImage = `img/hotels/h${randomIndex}.jpg`
    const hotelImageStyle = { backgroundImage: `url(${hotel.image ? hotel.image : randomImage})`}
    const allCategories = {...hotel.match.categories, ...hotel.match.hotel_types}
    const matchCategories = Object.values(allCategories).sort((a, b) => b.score - a.score )
    const matchCategoryIds = matchCategories.map(category => category.category_id)
    const matchFilterCategories = filterCategories.filter(filterCategory => {
      return matchCategoryIds.includes(JSON.parse(filterCategory).category_id)
    })
    const matchesTripType = hotel.match.trip_type !== "all"
    const categories = hotel.match.personalized_data_points ? matchCategories: hotel.categories
    const occasions = filterOccasions.filter(occasion => {
      return occasion.categories.some(category => matchCategoryIds.includes(category))
    })

    return <article className="hotel" id={hotel.ty_id} onClick={() => this.props.onHotelClicked(hotel)}>
      <div className="hotel-image" style={hotelImageStyle}></div>
      <div className="hotel-details">
        <div className="hotel-name">{hotel.name}</div>
        { hotel.distance_from_center && <div className="hotel-location">
            <i className="ty-icon ty-icon-map-marker"></i> {hotel.distance_from_center}
          </div>
        }
        { isPersonalizedSearch && <span className="hotel-match-score has-tooltip">
            <div className="tooltip">
              Matches {hotel.match.match_score}% to your preferences: overall review rating
              { hotel.match.personalized_data_points && <span>
                  , { matchFilterCategories.map(
                        category => {return JSON.parse(category).name.toLowerCase()}
                      ).join(', ')
                    }
                </span>
              }
              { matchesTripType && <span>, {hotel.match.trip_type} traveler</span> }
              { occasions && occasions.length > 0 && <span>, {occasions.map(occasion => occasion.id)} </span> }
            </div>
          <b>{hotel.match.match_score}% match for you</b>
          </span>
        }
        <div>
          Guest feedback
          { matchesTripType && <span> from <b>{hotel.match.trip_type}</b> trips</span> }
          {matchCategories && matchCategories.length > 0 && <span> on relevant topics</span>}:
        </div>
        <HotelCategories hotelId={hotel.ty_id} categories={categories} highlightCategories={hotel.match.personalized_data_points}/>
        <RelevantNow relevantNow={hotel.relevant_now} />
      </div>
      <div className="hotel-actions">
        <div className="trustscore">
          <div className="score">{hotel.score}</div>
          <div className="details">
            <div className="label">{hotel.score_description}</div>
            <div className="caption">{hotel.reviews_count ? hotel.reviews_count.toLocaleString(undefined): 0} reviews</div>
          </div>
        </div>
        <HotelBadges hotelId={hotel.ty_id} badges={hotel.badges} />
        <a className="action-primary btn btn-primary" href={`details.html?ty_id=${hotel.ty_id}`}>Book Now</a>
        <a className="action-secondary btn btn-text" href={`details.html?ty_id=${hotel.ty_id}`}>More details</a>
      </div>
    </article>
  }
}

class SearchResults extends React.Component {
  render() {
    if (this.props.hotels.length == 0) {
      return <NoResult />
    }

    return <div id="hotel-list">
      {this.props.hotels.map(
        hotel => <Hotel
          key={hotel.ty_id}
          onHotelClicked={this.props.onHotelClicked}
          hotel={hotel}
          isPersonalizedSearch={this.props.isPersonalizedSearch}
          filterOccasions={this.props.filterOccasions}
          filterCategories={this.props.filterCategories}
          randomIndex={getRandomImageIndex()}
        />)
      }
      {this.props.appendLoading && <Loader itemCount={2} />}
    </div>
  }
}

class SearchPage extends React.Component {
  state = {
    isLoadingHotel: true,
    isLoadingMore: false,
    isLoadingCategories: true,
    hotels: [],
    totalCount: null,
    mrCategories: [],
    error: null,
    filterCity: "",
    filterCountry: "",

    filterLat: null,
    filterLon: null,

    filterCategories: [],
    filterTrips: [],
    filterOccasions: [],
    isPersonalizedSearch: false,
    isOpenSearch: false,

    prevY: 0,
    pageSize: 10,
    currentPage: 0,
    hasNextPage: true,

    isMapFloating: false,
    newHotels: null,

    // Selected hotel, center in map
    selectedHotelId: null,
    centerLat: null,
    centerLon: null,
  }

  fetchSearchParamsInUrl = () => {
    const newState = {};
    var isPersonalizedSearch = false;

    const country = getLocationSearchInUrl("country");
    if (country) {
      newState["filterCountry"] = country;
    }
    const city = getLocationSearchInUrl("city");
    if (city) {
      newState["filterCity"] = city;
    }

    const pageSize = getLocationSearchInUrl("page_size");
    if (pageSize && !isNaN(parseInt(pageSize))) {
      newState["pageSize"] = parseInt(pageSize);
    }

    const filterTrips = getParamsInUrl("trip_type");
    if (filterTrips && filterTrips.length > 0) {
      isPersonalizedSearch = true;
      newState["filterTrips"] = filterTrips.map(id => {
        return ALL_TRIPS_INDEX[id];
      });
    }

    const filterOccasions = getParamsInUrl("occasions");
    if (filterOccasions && filterOccasions.length > 0) {
      isPersonalizedSearch = true;
      newState["filterOccasions"] = filterOccasions.map(id => {
        return ALL_OCCASIONS_INDEX[id];
      });
    }

    const filterCategories = getParamsInUrl("categories");
    if (filterCategories && filterCategories.length > 0) {
      isPersonalizedSearch = true;
      newState["filterCategories"] = filterCategories;
    }

    newState["isPersonalizedSearch"] = isPersonalizedSearch;

    return newState;
  }

  componentDidMount() {
    const selectedLocation = getLocationSearchInUrl("location");
    const locationFilter = parseCityCountry(selectedLocation);
    var newState = {
      isLoadingHotel: true,
      isLoadingCategories: true,
    }

    if (locationFilter) {
      // TODO Support lat,lon query
      if (this.state.filterCity != locationFilter[0] || this.state.filterCountry != locationFilter[1]) {
        newState["filterCity"] = locationFilter[0]
        newState["filterCountry"] = locationFilter[1]
      }
      newState = Object.assign({}, this.fetchSearchParamsInUrl(), newState);
      this.setState(newState, () => this.fetchHotels());
      this.fetchCategories();
    } else {
      window.location.href = "index.html"
    }

    var observerOptions = {
      root: null,
      rootMargin: "0px",
      threshold: 1.0
    };

    this.observer = new IntersectionObserver(
      this.handleObserver.bind(this),
      observerOptions
    );
    this.observer.observe(this.loadingRef);

    // float Map
    this.observerFloatMap = new IntersectionObserver(
      this.handleObserverFloatMap.bind(this),
      observerOptions
    );
    this.observerFloatMap.observe(this.floatMapRef);
  }

  handleObserverFloatMap(entities, observer) {
    /**
     * if The indicator is not in the viewport set map floating
     */
    const el = entities[0];
    var rect = el.boundingClientRect;

    var isMapFloating = false;

    if (rect.bottom < 0 || rect.top < 0) {
      isMapFloating = true;
    }

    this.setState({
      isMapFloating,
    });
  }

  handleObserver(entities, observer) {
    const y = entities[0].boundingClientRect.y;

    if (!this.state.isLoadingHotel && this.state.prevY > y && this.state.hasNextPage) {
      this.setState(
        { currentPage: this.state.currentPage +1, isLoadingMore: true },
        () => this.fetchHotels()
      );
    }
    this.setState({ prevY: y });
  }

  getMarkerPopup(hotel) {
    const { name, score, score_description} = hotel;
    return `<b>${name}</b>
        <div class="trustscore score-marker">
        <div class="score">${score}</div>
        <div class="details">
          <div class="label">${score_description}</div>
        </div>
      </div>
    `;
  }

  addMarkers = (hotels) => {
    this.setState({ newHotels: hotels})
  }

  buildAndStoreSearchUrl = () => {
    const { filterCountry, filterCity, filterCategories, filterOccasions } = this.state;
    var url = `country=${filterCountry}&city=${filterCity}`;
    var browserUrl = url;

    filterCategories.forEach(function(category) {
      url = `${url}&categories=${JSON.parse(category).category_id}`;
      browserUrl = `${browserUrl}&categories=${category}`;
    });

    this.state.filterTrips.forEach(function(trip) {
      url = `${url}&trip_type=${trip.id}`;
      browserUrl = `${browserUrl}&trip_type=${trip.id}`;
    });

    filterOccasions.forEach(function(occasion) {
      occasion.categories.forEach(cat => {
        url = `${url}&hotel_types=${cat}`;
      });
      browserUrl = `${browserUrl}&occasions=${occasion.id}`;
    });

    url = `${url}&page_size=${this.state.pageSize}&page=${this.state.currentPage}`;
    browserUrl = `${browserUrl}&page_size=${this.state.pageSize}`;

    const urlFull = `results.html?location=${filterCity}--${filterCountry}&${browserUrl}`;

    // Replace url to keep track search params
    if (`results.html${window.location.search}`.toUpperCase() !== encodeURI(urlFull).toUpperCase()) {
      window.history.replaceState(null, null, urlFull);
    }

    return url;
  }

  fetchHotels() {
    this.setState({
      isLoadingHotel: true,
    })

    const baseUrl = `${OTA_DEMO_API_URL}/api/v1/search/?`
    var url = this.buildAndStoreSearchUrl();

    this.fetchLocationCoordinates()
      .then(coordinates => {
        // Update mapbox
        if (coordinates) {
          this.setState({
            filterLat: coordinates.lat,
            filterLon: coordinates.lon
          })
        }

        axios({
          method: 'get',
          url: `${baseUrl}${url}`
        })
        .then(response => response.data)
        .then(data => {
          this.addMarkers(data.hotels);
          const hasNextPage = data.hotels.length == this.state.pageSize ? true : false;
          const hotels = this.state.currentPage == 0 ? data.hotels : this.state.hotels.concat(data.hotels);
          const totalCount = data.total_count;

          this.setState({
            hasNextPage,
            error: null,
            hotels,
            totalCount,
            isLoadingHotel: false,
            isLoadingMore: false,
            isOpenSearch: false,
          });
        })
        // Catch any errors we hit and update the app
        .catch(error => this.setState({ error, isLoadingHotel: false }));
      })
  }

  fetchLocationCoordinates() {
    /**
     * Get the coordinates of the city.
     *
     */
    const { filterCountry, filterCity, isLoadingMore } = this.state

    if (isLoadingMore) {
      // Loading more means location is not changed, ignore the fetch
      return Promise.resolve(null);
    }
    const coordinateUrl = `https://nominatim.openstreetmap.org/search?q=${filterCity},${filterCountry}&format=json&polygon=1&addressdetails=1`;

    return axios({
      method: 'get',
      url: coordinateUrl
    })
      .then(response => {
        if (response.data.length > 0) {
          return response.data[0];
        }
        return null;
      })
      .catch(() => null);
  }

  fetchCategories() {
    axios({
      method: 'get',
      url: `${OTA_DEMO_API_URL}/hotels/categories`
    })
        .then(response => {
          return response
        })
        .then(response => response.data.response.cluster_category_list)
        .then(categories =>
            this.setState({
              error: null,
              mrCategories: categories,
              isLoadingCategories: false,
            })
        )
        .catch(error => this.setState({ error, isLoadingCategories: false }));
  }

  onApplyLocationChange = (newLocation) => {
    /**
     * Change location will trigger new search
     * Reset to first page
     */
    const locationFilter = parseCityCountry(newLocation);
    if (locationFilter[0] !== this.state.filterCity || locationFilter[1] !== this.state.filterCountry) {
      this.setState({
        currentPage: 0,
        isLoadingMore: false,
        filterCity: locationFilter[0],
        filterCountry: locationFilter[1],
        totalCount: null,
      }, () => {
        this.fetchHotels();
      });
    }
  }

  onApplyChangesFilter = (data) => {
    /**
     * Apply new search, reset to the first page
     */
    var newState = {
      filterCategories: data.categories,
      filterTrips: data.tripTypes,
      filterOccasions: data.occasions,
      isPersonalizedSearch: !!(data.categories.length || data.tripTypes.length || data.occasions.length),
      currentPage: 0,
      isLoadingMore: false,
    }

    const locationFilter = parseCityCountry(data.location);
    if (locationFilter) {
      newState["filterCity"] = locationFilter[0]
      newState["filterCountry"] = locationFilter[1]
    }

    this.setState(newState, () => {
      this.fetchHotels();
    });
  }

  toggleSearch = () => {
    this.setState({
      isOpenSearch: !this.state.isOpenSearch,
    })
  }

  handleHotelClicked = (hotel) => {
    if (
      hotel.coordinates
      && this.state.centerLat !== hotel.coordinates[0]
      && this.state.centerLon !== hotel.coordinates[1]
    ) {
      this.setState({
        centerLat: hotel.coordinates[0],
        centerLon: hotel.coordinates[1],
        selectedHotelId: hotel.ty_id,
      })
    }
  }

  render() {
    return <>
      <SearchHeader
        toggleSearch={this.toggleSearch}
        isOpen={this.state.isOpenSearch}
        isSearching={this.state.isLoadingHotel}
        onApplyChanges={this.onApplyChangesFilter}
        onApplyLocationChange={this.onApplyLocationChange}
        mrCategories={this.state.mrCategories}
        categories={this.state.filterCategories}
        tripTypes={this.state.filterTrips}
        occasions={this.state.filterOccasions}
        totalCount={this.state.totalCount}
      />
      <span id="list-indicator" ref={floatMapRef => (this.floatMapRef = floatMapRef)}></span>

      <main>
        {(this.state.isLoadingMore || (!this.state.isLoadingHotel && !this.state.isLoadingCategories)) && !this.state.error &&
          <SearchResults
            hotels={this.state.hotels}
            filterOccasions={this.state.filterOccasions}
            filterCategories={this.state.filterCategories}
            isPersonalizedSearch={this.state.isPersonalizedSearch}
            onHotelClicked={this.handleHotelClicked}
            appendLoading={this.state.isLoadingMore}
          />
        }

        {!this.state.isLoadingHotel && !this.state.isLoadingCategories && this.state.error && <ErrorMessage/>}

        {this.state.isLoadingHotel && !this.state.isLoadingMore && <Loader itemCount={3} />}

        <MapContainer
          newHotels={this.state.newHotels}
          lat={this.state.filterLat}
          lon={this.state.filterLon}
          isStaleMap={this.state.isLoadingHotel && !this.state.isLoadingMore}
          centerLat={this.state.centerLat}
          centerLon={this.state.centerLon}
          selectedHotelId={this.state.selectedHotelId}
          isMapFloating={this.state.isMapFloating}
        />
      </main>

      <div className="footer-loader" ref={loadingRef => (this.loadingRef = loadingRef)}></div>
    </>
  }
}

ReactDOM.render(<SearchPage />, document.getElementById('search-page'))
      // Init default map
var RESULT_MAP = L.map('search-map').setView([48.1019351, 11.53698539037037], 13);

var RESULT_MAP_MARKERS = [];

const SCORE_DESCRIPTIONS = {
    "score_0": "Excellent",
    "score_1": "Very Good",
    "score_2": "Good",
    "score_3": "Fair",
    "score_4": "Poor"
}

const SCORE_THRESHOLDS = [86.0, 80.0, 74.0, 68.0, 0.0];

function applyThreshold(score) {
    for (const [index, value] of SCORE_THRESHOLDS.entries()) {
        if (score > value) {
            return index;
        }
    }
}

function getIcon(matchScore) {
    const scoreIndex = applyThreshold(matchScore);
    const scoreDescription = SCORE_DESCRIPTIONS[`score_${scoreIndex}`];
    const iconClass = scoreDescription.toLowerCase().replaceAll(" ", "");

    return L.divIcon({
        className: "trustyou-marker",
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
        iconAnchor: [0, 24],
        labelAnchor: [-6, 0],
        popupAnchor: [-6, -30],
        html: `<span class="map-marker marker-${iconClass}" />`
    });
}

function buildMap(lat, lon) {
    const mapConfig = {
        minZoom: 10,
        maxZoom: 16,
    }
    if (RESULT_MAP) {
        RESULT_MAP.remove();
        RESULT_MAP_MARKERS = [];
    }
    var map = L.map('search-map', mapConfig).setView([lat, lon], 13);

    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);
    RESULT_MAP = map;

    return map;
}

function markerOnClickHandler(e) {
    scrollTo(e.target.tyId);
}

function addMarker(tyId, matchScore, lat, lon, popupText) {

    if (!RESULT_MAP) {
        return;
    }
    cleanMarker(tyId);

    var marker = L.marker([lat, lon], {icon: getIcon(matchScore)})
        .bindPopup(popupText);
    marker.tyId = tyId;

    RESULT_MAP_MARKERS[tyId] = marker
        .addTo(RESULT_MAP)
        .on('click', markerOnClickHandler);
}

function cleanMarker(ty_id) {
    if (RESULT_MAP && RESULT_MAP_MARKERS && RESULT_MAP_MARKERS.hasOwnProperty(ty_id)) {
        // remove the marker
        RESULT_MAP.removeLayer(RESULT_MAP_MARKERS[ty_id]);
    }
}

    </script>
    <script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script type="text/javascript" src="js/main.js"></script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/axios/0.21.1/axios.min.js"></script>
    <script type="text/javascript" src="//unpkg.com/react@17/umd/react.production.min.js"></script>
    <script type="text/javascript" src="//unpkg.com/react-dom@17/umd/react-dom.production.min.js"></script>
    <script type="text/javascript" src="//unpkg.com/@babel/standalone@7.13.9/babel.min.js"></script>
    <script type="text/javascript" src="//unpkg.com/antd/dist/antd.min.js"></script>
    <link rel="stylesheet" href="//unpkg.com/antd/dist/antd.min.css"/>
    <script type="text/javascript" src="//unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>
    <link rel="stylesheet" href="//unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin=""/>
  </body>
</html>